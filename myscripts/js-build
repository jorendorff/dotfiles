#!/usr/bin/env python
# -*- Python -*-

import sys
import os, os.path, subprocess, platform
import re
import jsutil

if os.path.basename(os.getcwd()) != "src":
    import jsutil
    try:
        srcdir = jsutil.jssrc()
    except Exception, exc:
        print >>sys.stderr, "js-build:", exc
        sys.exit(1)
    os.chdir(srcdir)

FF_DIST = "../../obj-x86_64-unknown-linux-gnu/dist"

isWin = platform.system() == "Microsoft"
isMac = platform.system() == "Darwin"
isLinux = platform.system() == "Linux"
isGCC = not isWin
haveValgrind = not isWin and not isMac

if isMac:
    say = ["say"]
elif isLinux:
    say = ["espeak", "-v", "en-us"]
else:
    say = None

class Variant:
    def __init__(self, id):
        self.id = id
        self.dry_run = False
        self.hasGcZeal = 'd' in id

        if re.match(r'^o?[rdA]j?c?(?:32)?$', id) is None:
            raise ValueError("Unrecognized variant " + id)

        args = ['--enable-readline']
        cflags = []
        makeArgs = []
        env = {}

        if '32' in id and not (isMac or isLinux):
            raise ValueError("combination not supported")

        if isWin:
            for var in os.environ:
                env[var] = os.environ[var]
        else:
            for var in ['PATH']:
                if var in os.environ:
                    env[var] = os.environ[var]
            env['SHELL'] = '/bin/bash'

            if isMac:
                env['CC'] = 'clang'
                env['CXX'] = 'clang++'
                if '32' in id:
                    env['LD'] = 'ld'
                    env['CROSS_COMPILE'] = '1'
                    env['CC'] += ' -arch i386'
                    env['CXX'] += ' -arch i386'
            if isLinux and '32' in id:
                env['PKG_CONFIG_LIBDIR'] = '/usr/lib/pkgconfig'
                env['CC'] = 'gcc -m32'
                env['CXX'] = 'g++ -m32'
                env['AR'] = 'ar'
                args += ['--target=i686-pc-linux']

        if 'd' in id:
            assert 'A' not in id
            args += ['--disable-optimize']  # note that 'o' overrides this
            if isGCC:
                args += ['--enable-debug=-g3']
            else:
                args += ['--enable-debug']
            if haveValgrind:
                args += ['--enable-valgrind']
        elif 'A' in id:
            # Address sanitizer
            assert isLinux
            assert '32' not in id
            args += ['--enable-address-sanitizer', '--enable-debug-symbols', '--disable-threadsafe', '--disable-debug', '--enable-optimize=-O2 -g', '--enable-gczeal', '--enable-valgrind']
            env['LDFLAGS'] = "-fsanitize=address"
        else:
            args += ['--enable-debug-symbols']

        if 'o' in id:
            # optimized debug build
            if 'd' not in id:
                raise ValueError("o must be omitted when building non-debug; "
                                 "all non-debug builds are optimized automatically")
            i = args.index('--disable-optimize')
            args[i] = '--enable-optimize'

        if 'c' in id:
            assert 'd' in id
            cflags += ['-fprofile-arcs', '-ftest-coverage']

        dist = os.path.abspath(FF_DIST)
        nspr_include_dir = os.path.join(dist, "include", "nspr")
        nspr_lib_dir = os.path.join(dist, "lib")
        args += ['--with-nspr-cflags=-I' + nspr_include_dir,
                 '--with-nspr-libs=-L' + nspr_lib_dir + ' -lplds4 -lplc4 -lnspr4 -lpthread -ldl']
        args += ['--enable-ctypes']

        if 'j' in id:
            args += ['--enable-jemalloc']

        if cflags:
            for flag in cflags:
                assert re.match(r'^[0-9A-Za-z_-]*$', flag)
            env['CFLAGS'] = env['CXXFLAGS'] = ' '.join(cflags)

        self.configureArgs = args
        self.configureEnv = env
        self.makeArgs = makeArgs

    def build(self, cmd):
        objdir = self.id + "-obj"

        # configure
        cmd(["mkdir", "-p", objdir])
        config_ts = os.path.join(objdir, 'config.ts')
        if (not os.path.exists(config_ts)
            or os.path.getmtime('configure') >= os.path.getmtime(config_ts)):
            if not os.path.exists(config_ts):
                print("###  %r not found" % config_ts)
            elif os.path.getmtime('configure') >= os.path.getmtime(config_ts):
                print("### configure: %r; config.ts: %r" % (os.path.getmtime('configure'),
                                                            os.path.getmtime(config_ts)))
            else:
                print("### confused")

            script(cmd, ["../configure"] + self.configureArgs, cwd=objdir,
                   env=self.configureEnv)
            cmd(['touch', config_ts])

        # build
        cmd(["make", "-j9"] + self.makeArgs, cwd=objdir)

        # "local install"
        bindir = os.path.join(objdir, "dist", "bin")
        for filename in ("libnss3.dylib", "libmozglue.dylib"):
            lib = os.path.join(bindir, filename)
            if not os.path.isfile(lib) and not os.path.islink(lib):
                # extra ..s to get out of objdir
                os.symlink(os.path.join('..', '..', '..', FF_DIST, 'bin', filename), lib)

        # smoketest
        js = os.path.join(bindir, 'js')
        cmd([js, 'Y.js'])
        if self.hasGcZeal:
            cmd([js, '-e', 'gczeal(2)', 'Y.js'])

def autoconf(runcmd):
    if (not os.path.exists('configure')
        or os.path.getmtime('configure') <= os.path.getmtime('configure.in')):
        autoconf = 'autoconf213' if isMac else 'autoconf-2.13'
        script(runcmd, [autoconf])

def script(runcmd, command, **kwargs):
    if isWin:
        command = ["bash"] + command
    return runcmd(command, **kwargs)

def showCommand(command, cwd=None, env=None, stdout=None):
    """ Print the shell command line you could use to run the given command. """
    def quote(arg):
        if   re.match(r'^[a-zA-Z0-9_/=:\-\.\[\]]*$', arg):
            return arg
        elif re.match(r'^[a-zA-Z0-9_/=:\-\.\[\]\'\" ]*$', arg):
            return '"' + arg.replace('"', r'\"') + '"'
        else:
            return "'" + arg.replace("'", r"\'") + "'"
    stuff = []
    if cwd:
        stuff += ["cd", quote(cwd), "&&"]
    if env:
        stuff += ['%s=%s' % (k, quote(v)) for k, v in env.items()]
    stuff += [quote(arg) for arg in command]
    print(" ".join(stuff))

def runCommandVerbose(*args, **kwargs):
    discard_stdout = kwargs.pop("discard_stdout", False)
    with_colout = os.environ.get('EMACS') != 't' and sys.stdout.isatty() and args[0][0] == "make"

    print ">>> ",
    showCommand(*args, **kwargs)

    sink = None
    if discard_stdout:
        if os.name == 'posix':
            sink = open("/dev/null", "w")
        elif os.name == 'nt':
            sink = open("nul:", "w")
        else:
            discard_stdout = False

    if with_colout:
        destination = subprocess.PIPE
    else:
        destination = None  # no redirection

    if discard_stdout:
        kwargs['stdout'] = sink
        kwargs['stderr'] = destination
    else:
        kwargs['stdout'] = destination
        kwargs['stderr'] = subprocess.STDOUT

    try:
        p = last = subprocess.Popen(*args, **kwargs)
        if with_colout:
            output_pipe = last.stderr if discard_stdout else last.stdout
            last = subprocess.Popen(["colout", ": (error):", "red"], stdin=output_pipe,
                                 stdout=subprocess.PIPE)
            last = subprocess.Popen(["colout", ": (warning):", "#ff8000"], stdin=last.stdout)
        returncode = p.wait()  # get the exit code of the original process
        last.wait()            # but also wait for colout to be done
        if returncode != 0:
            raise subprocess.CalledProcessError(returncode, args)
        return returncode
    finally:
        if sink is not None:
            sink.close()

def runCommand(*args, **kwargs):
    return runCommandVerbose(*args, discard_stdout=True, **kwargs)

def main():
    import optparse
    p = optparse.OptionParser(usage="usage: %prog [-nv] [-V variants]")
    p.add_option("-v", "--verbose",
                 dest="verbose", action="store_true", default=False,
                 help="Print stdout from commands, not just stderr.")
    p.add_option("-V", "--variants",
                 dest="variants", default="od",
                 help="which variants to build")
    p.add_option("-n", "--dry-run",
                 dest="dry_run", action="store_true", default=False,
                 help="Don't actually run any commands; just print them.")
    (options, []) = p.parse_args()

    try:
        variants = [Variant(v.strip()) for v in options.variants.split(',')]
    except ValueError, exc:
        print >>sys.stderr, exc
        return 1

    if options.dry_run:
        runcmd = showCommand
    elif options.verbose:
        runcmd = runCommandVerbose
    else:
        runcmd = runCommand

    autoconf(runcmd)
    for v in variants:
        v.build(runcmd)

    if say:
        runcmd(say + ["build complete"])

if __name__ == '__main__':
    try:
        main()
    except:
        if say:
            subprocess.Popen(say + ["fail"])
        raise
